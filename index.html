<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Snake</title>
    <style>
        html {
            font-family: Arial, Helvetica, sans-serif;
        }

        #game-board {
            background-color: #ccc;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .snake-part {
            position: absolute;
            background-color: #000;
        }

        .food {
            position: absolute;
            height: 100px;
            width: 100px;
            background-color: blue;
        }

        #controller-pad {
            position: absolute;
            z-index: 1;
            text-align: center;
        }

        .controller-pad__second-row {
            display: flex;
        }

        #controller-pad .control {
            width: 40px;
            height: 40px;
            margin: 5px;
            background-color: red;
        }

        #menu {
            display: none;
            position: absolute;
            z-index: 1;
            top: 0;
            right: 0;
            left: 0;
            bottom: 0;
            background-color: #ccc;
            text-align: center;
        }

        .menu__header {
            text-transform: uppercase;
            font-size: 30px;
        }

        .menu__score {
            font-size: 20px;
        }

        #footer {
            position: absolute;
            right: 0;
            left: 0;
            bottom: 20px;
            text-align: center;
            padding-top: 50%;
            z-index: -1;
        }
    </style>
</head>

<body>
    <div id="score-display">score</div>
    <button id="quit-btn">QUIT (Q)</button>
    <button id="pause-btn">PAUSE (P)</button>
    <div id="game-board">
        <div id="menu"></div>
        <div id="controller-pad">
            <div class="controller-pad__first-row">
                <div class="control up">up</div>
            </div>
            <div class="controller-pad__second-row">
                <div class="control left">left</div>
                <div class="control down">down</div>
                <div class="control right">right</div>
            </div>
        </div>
    </div>

    <div id="footer">
        Made by Quá»‘c with luv
        <br />
        Source code
        <a style="text-decoration: none; color: #000; font-weight: 600"
            href="https://github.com/quocanhxemer/snake-game">here</a>
    </div>

    <script>
        // source: https://github.com/john-doherty/swiped-events/blob/master/dist/swiped-events.min.js
        !function (t, e) { "use strict"; "function" != typeof t.CustomEvent && (t.CustomEvent = function (t, n) { n = n || { bubbles: !1, cancelable: !1, detail: void 0 }; var a = e.createEvent("CustomEvent"); return a.initCustomEvent(t, n.bubbles, n.cancelable, n.detail), a }, t.CustomEvent.prototype = t.Event.prototype), e.addEventListener("touchstart", function (t) { if ("true" === t.target.getAttribute("data-swipe-ignore")) return; s = t.target, r = Date.now(), n = t.touches[0].clientX, a = t.touches[0].clientY, u = 0, i = 0 }, !1), e.addEventListener("touchmove", function (t) { if (!n || !a) return; var e = t.touches[0].clientX, r = t.touches[0].clientY; u = n - e, i = a - r }, !1), e.addEventListener("touchend", function (t) { if (s !== t.target) return; var e = parseInt(l(s, "data-swipe-threshold", "20"), 10), o = parseInt(l(s, "data-swipe-timeout", "500"), 10), c = Date.now() - r, d = "", p = t.changedTouches || t.touches || []; Math.abs(u) > Math.abs(i) ? Math.abs(u) > e && c < o && (d = u > 0 ? "swiped-left" : "swiped-right") : Math.abs(i) > e && c < o && (d = i > 0 ? "swiped-up" : "swiped-down"); if ("" !== d) { var b = { dir: d.replace(/swiped-/, ""), xStart: parseInt(n, 10), xEnd: parseInt((p[0] || {}).clientX || -1, 10), yStart: parseInt(a, 10), yEnd: parseInt((p[0] || {}).clientY || -1, 10) }; s.dispatchEvent(new CustomEvent("swiped", { bubbles: !0, cancelable: !0, detail: b })), s.dispatchEvent(new CustomEvent(d, { bubbles: !0, cancelable: !0, detail: b })) } n = null, a = null, r = null }, !1); var n = null, a = null, u = null, i = null, r = null, s = null; function l(t, n, a) { for (; t && t !== e.documentElement;) { var u = t.getAttribute(n); if (u) return u; t = t.parentNode } return a } }(window, document);
    </script>
    <script>
        const $ = document.querySelector.bind(document);
        const $$ = document.querySelectorAll.bind(document);
        document.addEventListener('swiped', function (e) {
            alert('swiped');
        });
        const game = {
            start() {
                this.init();
                this.loadConfig();

                this.drawGameBoard();
                this.drawSnake();
                this.handleSnakeControl();

                this.intervalId = setInterval(() => {
                    this.handleSnakeControl();
                    this.moveSnake();
                }, this.interval);
            },

            init() {
                // Prevent scrolling behaviours when pressing arrowkeys
                document.addEventListener("keydown", (event) => {
                    if (event.key === "ArrowUp" || event.key === "ArrowDown") {
                        event.view.event.preventDefault();
                    }
                });

                this.gameBoard = $("#game-board");
                this.gameBoardSize = { height: 30, width: 50 };
                this.snakeWidth = 20;
                this.currentDirection = "";
                this.snake = [{ x: 0, y: 0 }];
                this.snakeLength = 1;
                this.isPlaying = true;
                this.score = 0;
                this.isPaused = true;
                this.commandsList = [];
                this.commandsListLength = 0;

                // Clear remaining elements from previous games
                const oldElemets = $$(".snake-part,.food");
                console.log(oldElemets)
                for (let i = 0; i < oldElemets.length; i++) {
                    oldElemets[i].remove();
                }
            },

            loadConfig() {
                const data =
                    localStorage.getItem("snake-game") ||
                    // Default config
                    '{"interval":50,"boxMode":true,"highScore":0,"pauseOnStartup":false}';
                const config = JSON.parse(data);
                Object.assign(this, config);

                // Pause on startup handling
                if (!this.pauseOnStartup) {
                    this.isPaused = false;
                    this.commandsList.push("right");
                    this.commandsListLength++;
                }
            },

            drawGameBoard() {
                // Somewhat responsive
                while (
                    this.gameBoardSize.height * this.snakeWidth >=
                    window.innerHeight - 100
                ) {
                    this.gameBoardSize.height--;
                }
                while (
                    this.gameBoardSize.width * this.snakeWidth >=
                    window.innerWidth - 100
                ) {
                    this.gameBoardSize.width--;
                }

                Object.assign(this.gameBoard.style, {
                    height: `${this.gameBoardSize.height * this.snakeWidth}px`,
                    width: `${this.gameBoardSize.width * this.snakeWidth}px`,
                    border: this.boxMode ? "5px solid #e75353" : "none",
                });

                this.updateScore();
                this.renderFood();
            },

            renderFood() {
                // Render food element
                this.gameBoard.innerHTML += '<div class="food"></div>';

                foodPosition = this.newFoodPosition();
                if (foodPosition) {
                    Object.assign($(".food").style, {
                        width: `${this.snakeWidth}px`,
                        height: `${this.snakeWidth}px`,
                        top: `${foodPosition.y}px`,
                        left: `${foodPosition.x}px`,
                    });
                }
            },

            newFoodPosition() {
                let foodX, foodY;
                do {
                    // When there is no space left for food rendering
                    if (
                        this.snakeLength >=
                        this.gameBoardSize.height * this.gameBoardSize.width
                    ) {
                        this.end();
                        return null;
                    }

                    foodX =
                        (Math.random() * (this.gameBoardSize.width - 1)).toFixed() *
                        this.snakeWidth;
                    foodY =
                        (Math.random() * (this.gameBoardSize.height - 1)).toFixed() *
                        this.snakeWidth;
                } while (!this.isLegitFoodPosition(foodX, foodY));

                return {
                    x: foodX,
                    y: foodY,
                };
            },

            isLegitFoodPosition(foodX, foodY) {
                let check = true;
                this.snake.forEach((snakePart) => {
                    if (foodX === snakePart.x && foodY === snakePart.y) {
                        check = false;
                    }
                });
                return check;
            },

            updateScore() {
                const scoreText = $("#score-display");
                if (scoreText) {
                    scoreText.innerText = `Score: ${this.score}`;
                }
            },

            drawSnake() {
                // Clear game board
                const oldSnakePart = $$(".snake-part");
                for (let i = 0; i < oldSnakePart.length; i++) {
                    oldSnakePart[i].remove();
                }

                //Draw
                this.snake.forEach((element, index) => {
                    this.gameBoard.innerHTML += `<div class="snake-part id-${index}"></div>`;
                    const snakePart = $(`.snake-part.id-${index}`);
                    Object.assign(snakePart.style, {
                        width: `${this.snakeWidth}px`,
                        height: `${this.snakeWidth}px`,
                        top: `${element.y}px`,
                        left: `${element.x}px`,
                    });
                });
            },

            moveSnake() {
                this.advanceHead();
                this.handleCollision();

                if (!this.isPlaying || this.isPaused) {
                    return;
                }

                if (!this.isFoodEaten()) {
                    this.snake.pop();
                } else {
                    this.snakeLength++;
                    this.score++;
                    this.updateScore();

                    const newFoodPos = this.newFoodPosition();
                    Object.assign($(".food").style, {
                        top: newFoodPos.y + "px",
                        left: newFoodPos.x + "px",
                    });
                }

                this.drawSnake();
            },

            handleCollision() {
                const collidingStatus = this.isCollided();
                switch (collidingStatus) {
                    case 1:
                        this.end();
                        break;
                    case 2:
                        if (this.boxMode) {
                            this.end();
                        } else {
                            // Non-boxmode handling
                            const snakeHead = this.snake[0];
                            if (snakeHead.x >= this.gameBoardSize.width * this.snakeWidth) {
                                snakeHead.x = 0;
                            } else if (
                                snakeHead.y >=
                                this.gameBoardSize.height * this.snakeWidth
                            ) {
                                snakeHead.y = 0;
                            } else if (snakeHead.x < 0) {
                                snakeHead.x =
                                    (this.gameBoardSize.width - 1) * this.snakeWidth;
                            } else if (snakeHead.y < 0) {
                                snakeHead.y =
                                    (this.gameBoardSize.height - 1) * this.snakeWidth;
                            }
                        }
                        break;
                }
            },

            advanceHead() {
                if (!this.isPlaying || this.isPaused) {
                    return;
                }

                const snakeHead = this.snake[0];
                switch (this.currentDirection) {
                    case "up":
                        this.snake = [
                            { x: snakeHead.x, y: snakeHead.y - this.snakeWidth },
                            ...this.snake,
                        ];
                        break;
                    case "right":
                        this.snake = [
                            { x: snakeHead.x + this.snakeWidth, y: snakeHead.y },
                            ...this.snake,
                        ];
                        break;
                    case "down":
                        this.snake = [
                            { x: snakeHead.x, y: snakeHead.y + this.snakeWidth },
                            ...this.snake,
                        ];
                        break;
                    case "left":
                        this.snake = [
                            { x: snakeHead.x - this.snakeWidth, y: snakeHead.y },
                            ...this.snake,
                        ];
                        break;
                    default:
                        this.isPaused = true;
                        break;
                }
            },

            isFoodEaten() {
                if (
                    $(".food").style.top === $(".snake-part.id-0").style.top &&
                    $(".food").style.left === $(".snake-part.id-0").style.left
                ) {
                    return true;
                }
                return false;
            },

            isCollided() {
                const snakeHead = this.snake[0];
                for (let i = 1; i < this.snakeLength; i++) {
                    // Snake touches itself
                    if (
                        snakeHead.x === this.snake[i].x &&
                        snakeHead.y === this.snake[i].y
                    ) {
                        return 1;
                    }
                }

                // Snakes touches game board edge
                if (
                    snakeHead.x >= this.gameBoardSize.width * this.snakeWidth ||
                    snakeHead.y >= this.gameBoardSize.height * this.snakeWidth ||
                    snakeHead.x < 0 ||
                    snakeHead.y < 0
                ) {
                    return 2;
                }
                return 0;
            },

            handleSnakeControl() {
                document.addEventListener("keydown", (event) => {
                    switch (event.key) {
                        case "ArrowUp":
                        case "w":
                            this.addCommandsList("up");
                            break;
                        case "ArrowRight":
                        case "d":
                            this.addCommandsList("right");
                            break;
                        case "ArrowDown":
                        case "s":
                            this.addCommandsList("down");
                            break;
                        case "ArrowLeft":
                        case "a":
                            this.addCommandsList("left");
                            break;
                    }
                });

                if (this.commandsListLength) {
                    this.currentDirection = this.commandsList.shift();
                    this.commandsListLength--;
                    this.isPaused = false;
                }
            },

            addCommandsList(command) {
                // Command list takes new array element only when the new command "makes sense"
                switch (command) {
                    case "up":
                        if (
                            (this.commandsListLength &&
                                this.commandsList[this.commandsListLength - 1] !== "down" &&
                                this.commandsList[this.commandsListLength - 1] !== "up") ||
                            (!this.commandsListLength &&
                                this.currentDirection !== "down" &&
                                this.currentDirection !== "up")
                        ) {
                            this.commandsList.push("up");
                            this.commandsListLength++;
                        }
                        break;
                    case "right":
                        if (
                            (this.commandsListLength &&
                                this.commandsList[this.commandsListLength - 1] !== "left" &&
                                this.commandsList[this.commandsListLength - 1] !== "right") ||
                            (!this.commandsListLength &&
                                this.currentDirection !== "left" &&
                                this.currentDirection !== "right")
                        ) {
                            this.commandsList.push("right");
                            this.commandsListLength++;
                        }
                        break;
                    case "down":
                        if (
                            (this.commandsListLength &&
                                this.commandsList[this.commandsListLength - 1] !== "down" &&
                                this.commandsList[this.commandsListLength - 1] !== "up") ||
                            (!this.commandsListLength &&
                                this.currentDirection !== "down" &&
                                this.currentDirection !== "up")
                        ) {
                            this.commandsList.push("down");
                            this.commandsListLength++;
                        }
                        break;
                    case "left":
                        if (
                            (this.commandsListLength &&
                                this.commandsList[this.commandsListLength - 1] !== "left" &&
                                this.commandsList[this.commandsListLength - 1] !== "right") ||
                            (!this.commandsListLength &&
                                this.currentDirection !== "left" &&
                                this.currentDirection !== "right")
                        ) {
                            this.commandsList.push("left");
                            this.commandsListLength++;
                        }
                        break;
                }
            },

            end() {
                clearInterval(this.intervalId);
                this.isPlaying = false;
                this.highScore =
                    this.score > this.highScore ? this.score : this.highScore;
                this.showMenu();
            },

            retry() {
                this.end();
                $("#menu").style.display = "none";
                this.start();
            },

            showMenu() {
                $("#menu").style.display = "block";
                $("#menu").innerHTML = `
                    <h3 class="menu__header">game over</h3>
                    <p class="menu__score">Your score: ${this.score}</p>
                    <p class="menu__score">High score: ${this.highScore}</p>
                    <p>Game Settings</p>
                    <label for="speed">
                        Speed
                        <input type="range" name="speed" id="speed" />
                    </label>
                    <label for="box-mode">
                        <input type="checkbox" name="box-mode" id="box-mode" />
                        Box Mode
                    </label>
                    <label for="pause-startup">
                        <input type="checkbox" name="pause-startup" id="pause-startup" />
                        Pause the game on startup
                    </label>
                    <br />
                    <button id="retry-btn">SAVE AND RETRY (R)</button>
                    <button id="data-delete">DELETE DATA & RESET DEFAULT</button>
                `;
                this.handleSettings();
            },

            handleSettings() {
                $("#speed").value = 2000 / this.interval;
                $("#box-mode").checked = this.boxMode;
                $("#pause-startup").checked = this.pauseOnStartup;

                $("#retry-btn").onclick = () => {
                    const config = {
                        interval: Number($("#speed").value)
                            ? 2000 / Number($("#speed").value)
                            : 2000,
                        boxMode: $("#box-mode").checked,
                        highScore: this.highScore,
                        pauseOnStartup: $("#pause-startup").checked,
                    };
                    const data = JSON.stringify(config);
                    localStorage.setItem("snake-game", data);

                    this.retry();
                };

                $("#data-delete").onclick = () => {
                    localStorage.removeItem("snake-game");
                    this.loadConfig();
                    this.showMenu();
                };
            },
        };

        game.start();

        $("#quit-btn").onclick = () => {
            game.end();
        };

        $("#pause-btn").onclick = () => {
            game.isPaused = !game.isPaused;
        };

        // Shortcut handling
        document.addEventListener("keydown", (event) => {
            switch (event.key) {
                case "q":
                    game.end();
                    break;
                case "p":
                    game.isPaused = !game.isPaused;
                    break;
                case "r":
                    game.retry();
                    break;
            }
        });
    </script>
</body>

</html>